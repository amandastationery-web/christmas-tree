<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>3D Christmas Tree</title>

<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:#000;
  font-family:system-ui,-apple-system;
}
#ui{
  position:fixed;
  top:10px;
  left:10px;
  z-index:10;
}
#upload{
  background:#111;
  color:#d4af37;
  border:1px solid #d4af37;
  padding:8px;
}
#video{
  position:fixed;
  right:10px;
  bottom:10px;
  width:120px;
  border:1px solid gold;
  z-index:10;
}
</style>
</head>

<body>
<div id="ui">
  <input id="upload" type="file" accept="image/*" multiple />
</div>

<video id="video" autoplay playsinline></video>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ------------------ Three.js 场景 ------------------ */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000,5,20);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth/window.innerHeight,
  0.1,
  100
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({
  alpha:true,
  antialias:false,
  powerPreference:"low-power"
});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

/* 灯光 */
scene.add(new THREE.AmbientLight(0xffd700,0.4));
const spot = new THREE.SpotLight(0xffffff,1);
spot.position.set(5,10,5);
scene.add(spot);

/* 粒子圣诞树 */
const count = 800;
const geo = new THREE.BufferGeometry();
const pos = [];
for(let i=0;i<count;i++){
  const h = Math.random()*5;
  const r = (5-h)*Math.random()*0.4;
  const a = Math.random()*Math.PI*2;
  pos.push(Math.cos(a)*r, h-2.5, Math.sin(a)*r);
}
geo.setAttribute("position", new THREE.Float32BufferAttribute(pos,3));

const mat = new THREE.PointsMaterial({
  color:0xd4af37,
  size:0.06
});
const tree = new THREE.Points(geo,mat);
scene.add(tree);

/* ------------------ 照片 ------------------ */
const planes = [];
document.getElementById("upload").addEventListener("change",e=>{
  planes.forEach(p=>scene.remove(p));
  planes.length=0;

  [...e.target.files].slice(0,2).forEach((file,i)=>{
    const img = new Image();
    img.onload=()=>{
      const tex = new THREE.Texture(img);
      tex.needsUpdate=true;
      const m = new THREE.MeshBasicMaterial({map:tex});
      const g = new THREE.PlaneGeometry(2,2);
      const p = new THREE.Mesh(g,m);
      p.position.set(i?2:-2,0,0);
      scene.add(p);
      planes.push(p);
    };
    img.src = URL.createObjectURL(file);
  });
});

/* ------------------ MediaPipe 手势 ------------------ */
const video = document.getElementById("video");

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({
  maxNumHands:1,
  minDetectionConfidence:0.6,
  minTrackingConfidence:0.6
});

hands.onResults(res=>{
  if(!res.multiHandLandmarks) return;
  const lm = res.multiHandLandmarks[0];
  const d = Math.hypot(
    lm[4].x-lm[8].x,
    lm[4].y-lm[8].y
  );

  // 简化手势判断
  if(d < 0.05){
    camera.position.z = 6; // 捏合
  }else if(lm[8].y < lm[6].y){
    tree.rotation.y += 0.05; // 张开
  }else{
    camera.position.z = 10; // 握拳
  }
});

setTimeout(()=>{
  navigator.mediaDevices.getUserMedia({video:true}).then(stream=>{
    video.srcObject = stream;
    const cam = new Camera(video,{
      onFrame:async()=>{await hands.send({image:video});}
    });
    cam.start();
  });
},1500);

/* ------------------ 动画循环 ------------------ */
function animate(){
  requestAnimationFrame(animate);
  tree.rotation.y += 0.002;
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
